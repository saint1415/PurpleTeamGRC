#!/usr/bin/env python3
"""

Version: 3.0 - Updated for dynamic path detection
Vulnerability Scanner Module
Performs comprehensive vulnerability assessment using multiple tools
"""

import sys
import json
import yaml
import logging
import subprocess
import time
import random
from datetime import datetime
from pathlib import Path
import re

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Add parent directory to path for imports
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).parent.parent))

# Import path helper for dynamic paths
from utils.path_helper import BASE_DIR, CONFIG_FILE, RESULTS_DIR, LOGS_DIR
# Specific results directory
VULNERABILITY_SCANS_DIR = RESULTS_DIR / 'vulnerability-scans'

# Paths

class VulnerabilityScanner:
    """Comprehensive vulnerability scanner"""
    
    def __init__(self):
        self.config = self.load_config()
        self.results = {
            'scan_id': datetime.now().strftime('%Y%m%d_%H%M%S'),
            'scan_type': 'vulnerability_assessment',
            'start_time': datetime.now().isoformat(),
            'findings': [],
            'summary': {
                'critical': 0,
                'high': 0,
                'medium': 0,
                'low': 0,
                'info': 0
            }
        }
    
    def load_config(self):
        """Load configuration"""
        with open(CONFIG_FILE, 'r') as f:
            return yaml.safe_load(f)
    
    def calculate_delay(self):
        """Calculate random delay for stealth"""
        scanning_config = self.config.get('scanning', {})
        min_delay = scanning_config.get('random_delay_min', 0.5)
        max_delay = scanning_config.get('random_delay_max', 2.0)
        return random.uniform(min_delay, max_delay)
    
    def get_live_hosts(self):
        """Get list of live hosts from previous network scan"""
        # Find most recent network scan
        scan_files = sorted((RESULTS_DIR.parent / 'network-scans').glob('*.json'), reverse=True)
        
        if not scan_files:
            logger.warning("No previous network scan found, using config targets")
            # Support both 'ranges' and 'target_ranges' for compatibility
            network_config = self.config.get('network', {})
            targets = network_config.get('ranges') or network_config.get('target_ranges', [])
            
            if not targets:
                logger.error("No network ranges configured and no previous scan found")
                print("\n⚠️  No targets configured for vulnerability scan!")
                print("Please either:")
                print("  1. Run 'Network Discovery & Auto-Detection' (option 1) first")
                print("  2. Run 'Full Network Scan' (option 3) to discover hosts")
                print("  3. Configure network ranges in your config file")
                sys.exit(1)
            
            # Convert network ranges to individual IPs
            import ipaddress
            hosts = []
            for target_range in targets:
                try:
                    network = ipaddress.ip_network(target_range, strict=False)
                    # For vulnerability scanning, only scan first 10 IPs as a sample unless --full flag
                    for i, ip in enumerate(network.hosts()):
                        if i >= 10:  # Limit to 10 hosts for quick scan
                            break
                        hosts.append(str(ip))
                except ValueError as e:
                    logger.warning(f"Invalid network range {target_range}: {e}")
            
            if not hosts:
                logger.error("No valid hosts generated from network ranges")
                sys.exit(1)
                
            logger.info(f"Generated {len(hosts)} sample hosts from configured ranges")
            return hosts
        
        with open(scan_files[0], 'r') as f:
            network_data = json.load(f)
        
        hosts = [host['ip'] for host in network_data.get('hosts', [])]
        logger.info(f"Loaded {len(hosts)} hosts from previous scan")
        return hosts
    
    def scan_with_nuclei(self, targets):
        """Scan for vulnerabilities using Nuclei"""
        logger.info("Starting Nuclei vulnerability scan")
        
        findings = []
        nuclei_output = RESULTS_DIR / f"nuclei_{self.results['scan_id']}.json"
        
        # Create target file
        target_file = RESULTS_DIR / f"targets_{self.results['scan_id']}.txt"
        with open(target_file, 'w') as f:
            f.write('\n'.join(targets))
        
        try:
            cmd = [
                'nuclei',
                '-l', str(target_file),
                '-json',
                '-o', str(nuclei_output),
                '-severity', 'critical,high,medium,low',
                '-rate-limit', str(self.config.get('scanning', {}).get('max_rate', 100)),
                '-silent'
            ]
            
            subprocess.run(cmd, timeout=3600)  # 1 hour timeout
            
            # Parse results
            if nuclei_output.exists():
                with open(nuclei_output, 'r') as f:
                    for line in f:
                        try:
                            result = json.loads(line)
                            finding = {
                                'tool': 'nuclei',
                                'severity': result.get('info', {}).get('severity', 'info').lower(),
                                'title': result.get('info', {}).get('name', 'Unknown'),
                                'description': result.get('info', {}).get('description', ''),
                                'host': result.get('host', ''),
                                'matched_at': result.get('matched-at', ''),
                                'timestamp': datetime.now().isoformat()
                            }
                            findings.append(finding)
                            self.results['summary'][finding['severity']] += 1
                        except json.JSONDecodeError:
                            continue
            
            logger.info(f"Nuclei found {len(findings)} vulnerabilities")
            
        except subprocess.TimeoutExpired:
            logger.error("Nuclei scan timed out")
        except Exception as e:
            logger.error(f"Error running Nuclei: {e}")
        finally:
            # Cleanup
            if target_file.exists():
                target_file.unlink()
        
        return findings
    
    def scan_web_server(self, host):
        """Scan web server with Nikto"""
        logger.info(f"Scanning web server on {host}")
        
        findings = []
        
        # Check both HTTP and HTTPS
        for protocol in ['http', 'https']:
            url = f"{protocol}://{host}"
            output_file = RESULTS_DIR / f"nikto_{host}_{protocol}_{self.results['scan_id']}.txt"
            
            try:
                cmd = [
                    'nikto',
                    '-h', url,
                    '-Format', 'txt',
                    '-output', str(output_file),
                    '-Tuning', '123456789ab',  # All tests except DoS
                    '-timeout', '10'
                ]
                
                subprocess.run(cmd, timeout=1800, capture_output=True)
                
                # Parse results
                if output_file.exists():
                    with open(output_file, 'r') as f:
                        content = f.read()
                        
                        # Extract findings (simplified parsing)
                        for line in content.split('\n'):
                            if '+' in line and 'OSVDB' in line or 'CVE' in line:
                                finding = {
                                    'tool': 'nikto',
                                    'severity': 'medium',  # Default severity
                                    'title': f'Web Server Issue: {host}',
                                    'description': line.strip(),
                                    'host': host,
                                    'url': url,
                                    'timestamp': datetime.now().isoformat()
                                }
                                findings.append(finding)
                                self.results['summary']['medium'] += 1
                
                logger.info(f"Nikto found {len(findings)} issues on {url}")
                
            except subprocess.TimeoutExpired:
                logger.warning(f"Nikto scan timed out for {url}")
            except Exception as e:
                logger.error(f"Error running Nikto on {url}: {e}")
        
        return findings
    
    def scan_ssl_tls(self, host):
        """Scan SSL/TLS configuration"""
        logger.info(f"Scanning SSL/TLS on {host}")
        
        findings = []
        output_file = RESULTS_DIR / f"testssl_{host}_{self.results['scan_id']}.json"
        
        try:
            cmd = [
                "testssl.sh",
                '--jsonfile', str(output_file),
                '--quiet',
                '--fast',
                host
            ]
            
            subprocess.run(cmd, timeout=900, capture_output=True)
            
            # Parse results
            if output_file.exists():
                with open(output_file, 'r') as f:
                    for line in f:
                        try:
                            result = json.loads(line)
                            severity_map = {
                                'CRITICAL': 'critical',
                                'HIGH': 'high',
                                'MEDIUM': 'medium',
                                'LOW': 'low',
                                'OK': 'info'
                            }
                            
                            severity = severity_map.get(result.get('severity', 'INFO'), 'info')
                            
                            if severity in ['critical', 'high', 'medium']:
                                finding = {
                                    'tool': 'testssl.sh',
                                    'severity': severity,
                                    'title': result.get('id', 'SSL/TLS Issue'),
                                    'description': result.get('finding', ''),
                                    'host': host,
                                    'timestamp': datetime.now().isoformat()
                                }
                                findings.append(finding)
                                self.results['summary'][severity] += 1
                        except json.JSONDecodeError:
                            continue
            
            logger.info(f"testssl.sh found {len(findings)} SSL/TLS issues")
            
        except subprocess.TimeoutExpired:
            logger.warning(f"testssl.sh scan timed out for {host}")
        except Exception as e:
            logger.error(f"Error running testssl.sh on {host}: {e}")
        
        return findings
    
    def perform_vulnerability_scan(self):
        """Main vulnerability scanning function"""
        logger.info("Starting comprehensive vulnerability scan")
        
        # Get targets
        hosts = self.get_live_hosts()
        logger.info(f"Scanning {len(hosts)} hosts for vulnerabilities")
        
        # Run Nuclei scan on all hosts
        nuclei_findings = self.scan_with_nuclei(hosts)
        self.results['findings'].extend(nuclei_findings)
        
        # Individual host scans
        for idx, host in enumerate(hosts, 1):
            logger.info(f"Detailed scan of host {idx}/{len(hosts)}: {host}")
            
            # Web server scan
            web_findings = self.scan_web_server(host)
            self.results['findings'].extend(web_findings)
            
            # SSL/TLS scan
            ssl_findings = self.scan_ssl_tls(host)
            self.results['findings'].extend(ssl_findings)
            
            # Random delay between hosts
            if idx < len(hosts):
                delay = self.calculate_delay()
                logger.info(f"Sleeping for {delay:.2f} seconds (stealth)")
                time.sleep(delay)
        
        self.results['end_time'] = datetime.now().isoformat()
        self.results['summary']['total_findings'] = len(self.results['findings'])
        
        logger.info("Vulnerability scan completed")
        return self.results
    
    def save_results(self):
        """Save scan results"""
        RESULTS_DIR.mkdir(parents=True, exist_ok=True)
        
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"{timestamp}_VulnerabilityScan_Results.json"
        filepath = RESULTS_DIR / filename
        
        with open(filepath, 'w') as f:
            json.dump(self.results, f, indent=2)
        
        logger.info(f"Results saved to {filepath}")
        
        # Create HTML report
        self.create_html_report(filepath.with_suffix('.html'))
        
        # Create CSV export
        self.create_csv_report(filepath.with_suffix('.csv'))
    
    def create_html_report(self, filepath):
        """Create HTML vulnerability report"""
        html = f"""
<!DOCTYPE html>
<html>
<head>
    <title>Vulnerability Scan Report - {self.results['scan_id']}</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; }}
        h1 {{ color: #333; }}
        .critical {{ background-color: #f44336; color: white; }}
        .high {{ background-color: #ff9800; color: white; }}
        .medium {{ background-color: #ffeb3b; }}
        .low {{ background-color: #8bc34a; }}
        .info {{ background-color: #2196F3; color: white; }}
        table {{ border-collapse: collapse; width: 100%; margin-top: 20px; }}
        th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
        th {{ background-color: #4CAF50; color: white; }}
        .summary {{ background-color: #e7f3fe; padding: 15px; border-left: 6px solid #2196F3; margin-bottom: 20px; }}
        .severity-badge {{ padding: 5px 10px; border-radius: 3px; font-weight: bold; }}
    </style>
</head>
<body>
    <h1>Vulnerability Assessment Report</h1>
    <p><strong>Scan ID:</strong> {self.results['scan_id']}</p>
    <p><strong>Start Time:</strong> {self.results['start_time']}</p>
    <p><strong>End Time:</strong> {self.results['end_time']}</p>
    
    <div class="summary">
        <h2>Executive Summary</h2>
        <p><strong>Total Findings:</strong> {self.results['summary']['total_findings']}</p>
        <p><span class="severity-badge critical">Critical: {self.results['summary']['critical']}</span></p>
        <p><span class="severity-badge high">High: {self.results['summary']['high']}</span></p>
        <p><span class="severity-badge medium">Medium: {self.results['summary']['medium']}</span></p>
        <p><span class="severity-badge low">Low: {self.results['summary']['low']}</span></p>
        <p><span class="severity-badge info">Info: {self.results['summary']['info']}</span></p>
    </div>
    
    <h2>Detailed Findings</h2>
    <table>
        <tr>
            <th>Severity</th>
            <th>Title</th>
            <th>Host</th>
            <th>Tool</th>
            <th>Description</th>
        </tr>
"""
        
        # Sort findings by severity
        severity_order = {'critical': 0, 'high': 1, 'medium': 2, 'low': 3, 'info': 4}
        sorted_findings = sorted(
            self.results['findings'],
            key=lambda x: severity_order.get(x['severity'], 5)
        )
        
        for finding in sorted_findings:
            html += f"""
        <tr>
            <td><span class="severity-badge {finding['severity']}">{finding['severity'].upper()}</span></td>
            <td>{finding['title']}</td>
            <td>{finding['host']}</td>
            <td>{finding['tool']}</td>
            <td>{finding['description'][:200]}...</td>
        </tr>
"""
        
        html += """
    </table>
</body>
</html>
"""
        
        with open(filepath, 'w') as f:
            f.write(html)
        
        logger.info(f"HTML report saved to {filepath}")
    
    def create_csv_report(self, filepath):
        """Create CSV export"""
        import csv
        
        with open(filepath, 'w', newline='') as f:
            fieldnames = ['severity', 'title', 'host', 'tool', 'description', 'timestamp']
            writer = csv.DictWriter(f, fieldnames=fieldnames)
            
            writer.writeheader()
            for finding in self.results['findings']:
                writer.writerow({
                    'severity': finding['severity'],
                    'title': finding['title'],
                    'host': finding['host'],
                    'tool': finding['tool'],
                    'description': finding['description'],
                    'timestamp': finding['timestamp']
                })
        
        logger.info(f"CSV report saved to {filepath}")

def main():
    """Main entry point"""
    try:
        scanner = VulnerabilityScanner()
        results = scanner.perform_vulnerability_scan()
        scanner.save_results()
        logger.info("Vulnerability scanning completed successfully")
    except Exception as e:
        logger.error(f"Vulnerability scanning failed: {e}")
        raise

if __name__ == '__main__':
    main()
