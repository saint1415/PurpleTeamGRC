#!/usr/bin/env python3
"""
Purple Team GRC Platform v4.0
Detailed Vulnerability Output Formatter

Enriches vulnerability scan results with comprehensive metadata including:
- CVE/CWE information
- CVSS scores and vectors
- Exploit availability
- Patch status
- Business impact
- Remediation guidance
- Compliance mapping

Usage:
  from vulnerability_formatter import VulnerabilityFormatter
  
  formatter = VulnerabilityFormatter()
  enriched_vuln = formatter.enrich_vulnerability(basic_vuln_data)
"""

import sys
import json
from pathlib import Path
from datetime import datetime

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

class VulnerabilityFormatter:
    """Enrich and format vulnerability data with detailed metadata"""
    
    def __init__(self):
        # CVE database (in production, this would query NVD API)
        self.cve_database = self._load_cve_database()
        
        # CWE mappings
        self.cwe_mappings = {
            'telnet': 'CWE-319: Cleartext Transmission of Sensitive Information',
            'http': 'CWE-319: Cleartext Transmission of Sensitive Information',
            'weak_auth': 'CWE-287: Improper Authentication',
            'default_creds': 'CWE-798: Use of Hard-coded Credentials',
            'smb_exposed': 'CWE-284: Improper Access Control',
            'rdp_exposed': 'CWE-284: Improper Access Control'
        }
        
        # Compliance framework mappings
        self.compliance_mappings = {
            'unencrypted_service': {
                'SOC2': ['CC6.1 - Logical and Physical Access Controls', 'CC6.7 - System Monitoring'],
                'PCI-DSS': ['2.2.2 - Enable only necessary services', '4.1 - Use strong cryptography'],
                'HIPAA': ['164.312(a)(2)(iv) - Encryption and Decryption', '164.312(e)(1) - Transmission Security'],
                'NIST': ['SC-8 - Transmission Confidentiality', 'AC-17 - Remote Access'],
                'ISO27001': ['A.10.1.1 - Policy on the use of cryptographic controls', 'A.13.1.1 - Network controls']
            },
            'weak_authentication': {
                'SOC2': ['CC6.1 - Logical and Physical Access Controls'],
                'PCI-DSS': ['8.2.1 - Use strong authentication', '8.2.3 - Multi-factor authentication'],
                'HIPAA': ['164.312(a)(2)(i) - Unique User Identification', '164.312(d) - Person or Entity Authentication'],
                'NIST': ['IA-2 - Identification and Authentication', 'IA-5 - Authenticator Management'],
                'ISO27001': ['A.9.2.1 - User registration', 'A.9.4.2 - Secure log-on procedures']
            }
        }
    
    def _load_cve_database(self):
        """Load CVE database (simplified for demo)"""
        return {
            'telnet': {
                'cve_id': 'CVE-2019-12345',
                'cvss_score': 9.8,
                'cvss_vector': 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H',
                'description': 'Telnet protocol transmits credentials in plaintext',
                'exploit_available': True,
                'exploit_maturity': 'Functional',
                'patch_available': True
            },
            'http': {
                'cve_id': 'Generic-HTTP',
                'cvss_score': 7.5,
                'cvss_vector': 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N',
                'description': 'HTTP transmits data without encryption',
                'exploit_available': True,
                'exploit_maturity': 'Functional',
                'patch_available': True
            }
        }
    
    def enrich_vulnerability(self, vuln_data, host_info=None):
        """
        Enrich basic vulnerability data with comprehensive metadata
        
        Args:
            vuln_data: Basic vulnerability info (port, service, etc.)
            host_info: Optional host context (IP, OS, etc.)
        
        Returns:
            Enriched vulnerability dictionary
        """
        enriched = {
            'vulnerability_id': self._generate_vuln_id(vuln_data),
            'discovered_date': datetime.now().isoformat(),
            'basic_info': vuln_data,
            'host_context': host_info or {},
            'severity_analysis': self._analyze_severity(vuln_data),
            'cve_cwe_info': self._get_cve_cwe_info(vuln_data),
            'exploit_info': self._get_exploit_info(vuln_data),
            'patch_info': self._get_patch_info(vuln_data),
            'business_impact': self._assess_business_impact(vuln_data),
            'compliance_impact': self._get_compliance_impact(vuln_data),
            'remediation': self._generate_remediation(vuln_data),
            'references': self._get_references(vuln_data),
            'metadata': {
                'false_positive_likelihood': self._assess_false_positive(vuln_data),
                'verified': True,
                'confidence': 'high'
            }
        }
        
        return enriched
    
    def _generate_vuln_id(self, vuln_data):
        """Generate unique vulnerability ID"""
        service = vuln_data.get('service', 'unknown')
        port = vuln_data.get('port', '0')
        timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
        return f"VULN-{service.upper()}-{port}-{timestamp}"
    
    def _analyze_severity(self, vuln_data):
        """Analyze and categorize vulnerability severity"""
        service = vuln_data.get('service', '').lower()
        port = vuln_data.get('port', 0)
        
        # Determine severity based on service type
        if service == 'telnet' or port == 23:
            severity = 'critical'
            cvss = 9.8
            risk_score = 95
        elif service == 'http' or port == 80:
            severity = 'high'
            cvss = 7.5
            risk_score = 75
        elif service in ['smb', 'microsoft-ds', 'netbios-ssn']:
            severity = 'high'
            cvss = 8.1
            risk_score = 80
        elif service == 'rdp' or port == 3389:
            severity = 'high'
            cvss = 7.8
            risk_score = 78
        elif service == 'ssh' or port == 22:
            severity = 'medium'
            cvss = 5.3
            risk_score = 50
        else:
            severity = 'low'
            cvss = 3.0
            risk_score = 30
        
        return {
            'severity': severity,
            'cvss_v3_score': cvss,
            'risk_score': risk_score,
            'severity_justification': self._get_severity_justification(service, severity)
        }
    
    def _get_severity_justification(self, service, severity):
        """Explain why this severity was assigned"""
        justifications = {
            'telnet': 'Credentials transmitted in cleartext, complete credential compromise possible',
            'http': 'Session data transmitted in cleartext, susceptible to man-in-the-middle attacks',
            'smb': 'Known vulnerabilities (EternalBlue), lateral movement risk',
            'rdp': 'Common ransomware entry point, brute force target',
            'ssh': 'Properly configured SSH is secure, but may have weak configuration'
        }
        return justifications.get(service, f'Rated as {severity} based on exposure and exploitability')
    
    def _get_cve_cwe_info(self, vuln_data):
        """Get CVE and CWE information"""
        service = vuln_data.get('service', '').lower()
        
        # Get CVE data
        cve_data = self.cve_database.get(service, {})
        
        # Get CWE
        cwe = self.cwe_mappings.get(service, 'CWE-1035: OWASP Top Ten 2017 Category A9 - Using Components with Known Vulnerabilities')
        
        return {
            'cve_ids': [cve_data.get('cve_id')] if cve_data.get('cve_id') else [],
            'cwe_ids': [cwe],
            'cvss_vector': cve_data.get('cvss_vector', 'Not available'),
            'nvd_link': f"https://nvd.nist.gov/vuln/detail/{cve_data.get('cve_id')}" if cve_data.get('cve_id') else None
        }
    
    def _get_exploit_info(self, vuln_data):
        """Get exploit availability information"""
        service = vuln_data.get('service', '').lower()
        
        exploit_info = {
            'exploit_available': False,
            'exploit_maturity': 'none',
            'exploit_sources': [],
            'proof_of_concept_available': False,
            'active_internet_scanning': False
        }
        
        # Check for known exploits
        if service == 'telnet':
            exploit_info.update({
                'exploit_available': True,
                'exploit_maturity': 'Functional',
                'exploit_sources': [
                    'Metasploit: auxiliary/scanner/telnet/telnet_login',
                    'Hydra: Brute force tool',
                    'Ncrack: Network authentication cracking'
                ],
                'proof_of_concept_available': True,
                'active_internet_scanning': True,
                'public_exploits': 'Multiple public exploits available',
                'exploitation_complexity': 'Low - automated tools available'
            })
        elif service == 'http':
            exploit_info.update({
                'exploit_available': True,
                'exploit_maturity': 'Functional',
                'exploit_sources': [
                    'Various MITM tools (Ettercap, Bettercap)',
                    'SSL Strip attacks'
                ],
                'proof_of_concept_available': True,
                'active_internet_scanning': False,
                'exploitation_complexity': 'Medium - requires network position'
            })
        elif service in ['smb', 'microsoft-ds']:
            exploit_info.update({
                'exploit_available': True,
                'exploit_maturity': 'High',
                'exploit_sources': [
                    'EternalBlue (MS17-010)',
                    'Metasploit: exploit/windows/smb/ms17_010_eternalblue',
                    'SMBGhost (CVE-2020-0796)'
                ],
                'proof_of_concept_available': True,
                'active_internet_scanning': True,
                'exploitation_complexity': 'Low - reliable exploits exist'
            })
        
        return exploit_info
    
    def _get_patch_info(self, vuln_data):
        """Get patching/remediation availability"""
        service = vuln_data.get('service', '').lower()
        
        patch_info = {
            'patch_available': True,
            'vendor_advisory': None,
            'fixed_versions': [],
            'workarounds_available': True
        }
        
        if service == 'telnet':
            patch_info.update({
                'patch_available': True,
                'remediation_type': 'Service Replacement',
                'recommended_action': 'Disable telnet, enable SSH',
                'vendor_advisory': 'Most vendors recommend disabling telnet entirely',
                'estimated_patch_time': '15-30 minutes'
            })
        elif service == 'http':
            patch_info.update({
                'patch_available': True,
                'remediation_type': 'Protocol Upgrade',
                'recommended_action': 'Enable HTTPS with TLS 1.2+',
                'vendor_advisory': 'Implement HTTPS with proper certificate',
                'estimated_patch_time': '1-2 hours'
            })
        
        return patch_info
    
    def _assess_business_impact(self, vuln_data):
        """Assess business impact of vulnerability"""
        service = vuln_data.get('service', '').lower()
        
        impact = {
            'confidentiality': 'MEDIUM',
            'integrity': 'MEDIUM',
            'availability': 'LOW'
        }
        
        if service == 'telnet':
            impact = {
                'confidentiality': 'HIGH',
                'integrity': 'HIGH',
                'availability': 'HIGH',
                'business_impact_description': 'Complete device compromise possible, credentials stolen, configuration modified, service disruption',
                'data_at_risk': 'Administrative credentials, device configuration, network topology',
                'potential_consequences': [
                    'Unauthorized administrative access',
                    'Network device misconfiguration',
                    'Lateral movement to other systems',
                    'Service disruption',
                    'Data exfiltration'
                ]
            }
        elif service == 'http':
            impact = {
                'confidentiality': 'HIGH',
                'integrity': 'MEDIUM',
                'availability': 'LOW',
                'business_impact_description': 'Session hijacking, credential theft, data interception possible',
                'data_at_risk': 'User credentials, session tokens, transmitted data',
                'potential_consequences': [
                    'User account compromise',
                    'Session hijacking',
                    'Data interception',
                    'Man-in-the-middle attacks'
                ]
            }
        
        return impact
    
    def _get_compliance_impact(self, vuln_data):
        """Map vulnerability to compliance requirements"""
        service = vuln_data.get('service', '').lower()
        
        # Determine category
        if service in ['telnet', 'http']:
            category = 'unencrypted_service'
        else:
            category = 'weak_authentication'
        
        frameworks = self.compliance_mappings.get(category, {})
        
        impact = {
            'regulatory_frameworks_affected': list(frameworks.keys()),
            'specific_controls': frameworks,
            'audit_implications': self._get_audit_implications(service),
            'remediation_required_for_compliance': True
        }
        
        return impact
    
    def _get_audit_implications(self, service):
        """Determine audit implications"""
        if service == 'telnet':
            return [
                'Likely audit finding',
                'May result in qualified opinion',
                'Requires immediate remediation for certification',
                'Could impact SOC 2 Type II attestation'
            ]
        elif service == 'http':
            return [
                'Possible audit finding',
                'May require compensating controls',
                'Document risk acceptance if remediation delayed'
            ]
        else:
            return ['Document in audit workpapers', 'May require management response']
    
    def _generate_remediation(self, vuln_data):
        """Generate detailed remediation guidance"""
        service = vuln_data.get('service', '').lower()
        port = vuln_data.get('port', 0)
        
        remediation = {
            'priority': 'high',
            'estimated_effort': 'Medium',
            'estimated_cost': 'Low',
            'remediation_steps': [],
            'immediate_actions': [],
            'short_term_actions': [],
            'long_term_actions': [],
            'workarounds': [],
            'validation_steps': []
        }
        
        if service == 'telnet' or port == 23:
            remediation.update({
                'priority': 'critical',
                'estimated_effort': 'Low (15-30 minutes)',
                'estimated_cost': '$0 (configuration change)',
                'immediate_actions': [
                    'Disable telnet service immediately',
                    'Verify SSH is available as alternative'
                ],
                'short_term_actions': [
                    'Enable SSH on device',
                    'Configure strong SSH authentication (keys preferred)',
                    'Test SSH connectivity',
                    'Disable telnet service permanently'
                ],
                'long_term_actions': [
                    'Implement centralized authentication (RADIUS/TACACS+)',
                    'Enable logging and monitoring of management access',
                    'Implement jump host for infrastructure access'
                ],
                'workarounds': [
                    'If telnet must remain: Restrict to management VLAN only',
                    'Implement ACLs limiting source IPs',
                    'Use VPN for remote management access'
                ],
                'validation_steps': [
                    'Verify telnet port (23) is closed',
                    'Verify SSH port (22) is accessible',
                    'Test SSH login functionality',
                    'Run follow-up security scan'
                ]
            })
        elif service == 'http' or port == 80:
            remediation.update({
                'priority': 'high',
                'estimated_effort': 'Medium (1-2 hours)',
                'estimated_cost': 'Low ($0-100 for cert)',
                'immediate_actions': [
                    'Obtain SSL/TLS certificate (Let\'s Encrypt free option)'
                ],
                'short_term_actions': [
                    'Install certificate on web server',
                    'Configure HTTPS (port 443)',
                    'Set up HTTP to HTTPS redirect',
                    'Configure HSTS header'
                ],
                'long_term_actions': [
                    'Implement certificate auto-renewal',
                    'Monitor certificate expiration',
                    'Regular SSL configuration testing'
                ],
                'validation_steps': [
                    'Verify HTTPS accessible on port 443',
                    'Test HTTP to HTTPS redirect',
                    'Run testssl.sh to verify configuration',
                    'Check SSL Labs rating (A or better)'
                ]
            })
        
        return remediation
    
    def _get_references(self, vuln_data):
        """Get reference links and documentation"""
        service = vuln_data.get('service', '').lower()
        
        references = {
            'vendor_advisories': [],
            'cve_databases': [],
            'kb_articles': [],
            'community_resources': []
        }
        
        if service == 'telnet':
            references.update({
                'vendor_advisories': [
                    'https://www.cisco.com/c/en/us/support/docs/security/secure-shell-ssh/4145-ssh.html'
                ],
                'cve_databases': [
                    'https://nvd.nist.gov/vuln/search/results?form_type=Basic&results_type=overview&query=telnet'
                ],
                'kb_articles': [
                    'https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_install_firstuse'
                ],
                'community_resources': [
                    'https://www.ssh.com/academy/ssh',
                    'OWASP: Using Components with Known Vulnerabilities'
                ]
            })
        
        return references
    
    def _assess_false_positive(self, vuln_data):
        """Assess likelihood of false positive"""
        service = vuln_data.get('service', '').lower()
        
        # Services like telnet/HTTP are definitive
        if service in ['telnet', 'http', 'ftp']:
            return 'very_low'
        elif service in ['ssh', 'https']:
            return 'medium'  # Depends on configuration
        else:
            return 'low'
    
    def format_json(self, enriched_vuln, pretty=True):
        """Format enriched vulnerability as JSON"""
        if pretty:
            return json.dumps(enriched_vuln, indent=2)
        return json.dumps(enriched_vuln)
    
    def format_text(self, enriched_vuln):
        """Format enriched vulnerability as human-readable text"""
        lines = []
        lines.append("=" * 70)
        lines.append(f"VULNERABILITY DETAILS: {enriched_vuln['vulnerability_id']}")
        lines.append("=" * 70)
        lines.append("")
        
        # Basic info
        basic = enriched_vuln['basic_info']
        lines.append(f"Service: {basic.get('service', 'unknown')}")
        lines.append(f"Port: {basic.get('port', 'unknown')}")
        lines.append(f"Protocol: {basic.get('protocol', 'tcp')}")
        lines.append("")
        
        # Severity
        severity = enriched_vuln['severity_analysis']
        lines.append(f"Severity: {severity['severity'].upper()}")
        lines.append(f"CVSS Score: {severity['cvss_v3_score']}")
        lines.append(f"Risk Score: {severity['risk_score']}/100")
        lines.append(f"Justification: {severity['severity_justification']}")
        lines.append("")
        
        # CVE/CWE
        cve_cwe = enriched_vuln['cve_cwe_info']
        if cve_cwe['cve_ids']:
            lines.append(f"CVE IDs: {', '.join(cve_cwe['cve_ids'])}")
        if cve_cwe['cwe_ids']:
            lines.append(f"CWE: {cve_cwe['cwe_ids'][0]}")
        lines.append("")
        
        # Exploit info
        exploit = enriched_vuln['exploit_info']
        lines.append(f"Exploit Available: {'Yes' if exploit['exploit_available'] else 'No'}")
        if exploit['exploit_available']:
            lines.append(f"Exploit Maturity: {exploit['exploit_maturity']}")
            lines.append(f"Exploitation Complexity: {exploit.get('exploitation_complexity', 'Unknown')}")
        lines.append("")
        
        # Business impact
        impact = enriched_vuln['business_impact']
        lines.append("Business Impact:")
        lines.append(f"  Confidentiality: {impact.get('confidentiality', 'Unknown')}")
        lines.append(f"  Integrity: {impact.get('integrity', 'Unknown')}")
        lines.append(f"  Availability: {impact.get('availability', 'Unknown')}")
        if 'business_impact_description' in impact:
            lines.append(f"  Description: {impact['business_impact_description']}")
        lines.append("")
        
        # Remediation
        remediation = enriched_vuln['remediation']
        lines.append("Remediation:")
        lines.append(f"  Priority: {remediation['priority'].upper()}")
        lines.append(f"  Effort: {remediation['estimated_effort']}")
        lines.append(f"  Cost: {remediation['estimated_cost']}")
        lines.append("")
        lines.append("  Immediate Actions:")
        for action in remediation.get('immediate_actions', []):
            lines.append(f"    â€¢ {action}")
        lines.append("")
        
        return "\n".join(lines)

# Example usage
if __name__ == '__main__':
    # Demo vulnerability data
    telnet_vuln = {
        'service': 'telnet',
        'port': 23,
        'protocol': 'tcp'
    }
    
    http_vuln = {
        'service': 'http',
        'port': 80,
        'protocol': 'tcp'
    }
    
    formatter = VulnerabilityFormatter()
    
    print("Detailed Vulnerability Formatter Demo\n")
    
    # Enrich and format telnet vulnerability
    enriched_telnet = formatter.enrich_vulnerability(
        telnet_vuln,
        host_info={'ip': '192.168.1.67', 'hostname': 'dell-switch.local'}
    )
    
    print(formatter.format_text(enriched_telnet))
    print("\n" + "=" * 70)
    print("JSON Format (truncated):")
    print(formatter.format_json(enriched_telnet, pretty=True)[:500] + "...\n")
